\subsection{Zadanie 1 -- Algorytm Bellmana-Forda z odtwarzaniem ścieżki}
\paragraph{Treść.}Zmodyfikuj algorytm Bellmana-Forda tak, 
aby znajdował najkrótszą ścieżkę między zadanymi dwoma
wierzchołkami.

\paragraph{Rozwiązanie.}

\begin{algorithm}[H]
	\caption{Algorytm Bellmana-Forda z odtwarzaniem ścieżki}
	\begin{algorithmic}[1]
		\Procedure{BellmanFord}{$(G, w)$: graf ważony, $s$: wierzchołek startowy, $t$: wierzchołek docelowy}

		\State odległość = tablica liczb, rozmiaru $V[G]$
		\State poprzednik = tablica wierzchołków, rozmiaru $V[G]$
		\For{$v \in V(G)$}
		\State odległość$[v]\gets\infty$
		\State poprzednik$[v]\gets-1$
		\EndFor
		\State odległość$[s]\gets0$
		\For{$i=1,2,\dots,n-1$}
		\For{$uv \in E(G)$}
		\If{odległość$[v] >$ odległość$[u]$ + $w(uv)$}
		\State odległość$[v]\gets$ odległość$[u] + w(uv)$ 
		\State poprzednik$[v]\gets u$
		\EndIf
		\EndFor
		\EndFor
		\State ścieżka $\gets$ pusta lista wierzchołków
		\State ściezka.PushFront($t$)
		\While{$t \gets \text{poprzednik}[t] \not = -1$}
		\State ścieżka.PushFront($t$)
		\EndWhile
		\State \Return ścieżka
		\EndProcedure
	\end{algorithmic}
	\label{Zadanie31}
\end{algorithm}
\subsection{Zadanie 2 -- Szukanie ujemnego cyklu}
\paragraph{Treść.}Zaprojektuj algorytm, który znajdzie w 
ważonym grafie skierowanym ujemny cykl, jeśli taki istnieje.
Wskazówka: zmodyfikuj algorytm Bellmana-Forda.

\paragraph{Rozwiązanie.}
Rozwiązanie polega na sprawdzeniu, czy wykonanie
jeszcze jednej nadmiarowej iteracji 
w algorytmie Bellmana-Forda %robi co??
, oraz sprawdzenie
czy pewien wierzchołek został poprawiony. % ale co z tym sprawdzeniem?

Jeżeli poniższy warunek jest spełniony
\[\exists_{v\in V(G)}\quad \text{odległość}_n[v] < \text{odległość}_{n-1}[v],\]
to w grafie $G$ musi istnieć ujemny cykl. Dzieje się 
tak, ponieważ zawsze istnieje co najmniej jedna krawędź 
w cyklu ujemnym $C$, która spełnia warunek 
\[\text{odległość}[v] > \text{odległość}[u] + w(uv),\]
zatem będzie wtedy istniał wierzchołek, który zostanie 
poprawiony.

Jako że graf wejściowy może być niespójny,
musimy dodać dodatkowy wierzchołek $s$, który
będzie połączony z każdym innym wierzchołkiem
przy pomocy krawędzi skierowanej od wierzchołka $s$. Jako
że żadna krawędź nie wchodzi do wierzchołka $s$, możemy mieć pewność,
że żadne nowe cykle nie powstaną. Zatem
w szczególności nie powstaną nowe
ujemne cykle.

\begin{algorithm}[H]
	\caption{Znajdowanie ujemnego cyklu}
	\begin{algorithmic}[1]
		\Procedure{BellmanFord}{($G, w$): graf ważony}
		\State $G'$ $\gets$ graf $G$ z dodanym wierzchołkiem $s$
		oraz krawędziami skierowanymi od $s$ do każdego innego
		wierzchołka o wadze $0$
		\State odległość $\gets$ tablica liczb, rozmiaru $V[G']$
		\For{$v \in V(G')$}
		\State odległość$[v]\gets\infty$
		\EndFor
		\State odległość$[s]\gets0$
		\For{$i=1,2,\dots,n-1$}
		\For{$uv \in E(G')$}
		\If{odległość$[v] >$ odległość$[u]$ + $w(uv)$}
		\State odległość$[v]\gets$ odległość$[u] + w(uv)$ 
		\EndIf
		\EndFor
		\EndFor
		\For{$uv \in E(G')$}
		\If{odległość$[v] >$ odległość$[u]$ + $w(uv)$}
		\State return \true
		\EndIf
		\EndFor
		\State \Return \false
		\EndProcedure
	\end{algorithmic}
	\label{Zadanie32}
\end{algorithm}

\subsection{Zadanie 3 -- Szukanie liczby spacerów o zadanej liczbie krawędzi}
\paragraph{Treść.}
Zaprojektuj algorytm, który dla danego grafu prostego 
$G$, wierzchołków $u, v \in V(G)$ i liczby $k \in
\{1, 2, \ldots , n\}$ znajdzie liczbę spacerów 
od $u$ do $v$ o dokładnie $k$ krawędziach.

%\paragraph{Rozwiązanie.}% :(

\subsection{Zadanie 4 -- Wyznaczanie odległości w drzewie ważonym}
\paragraph{Treść.}Zaprojektuj algorytm, który dla ważonego 
acyklicznego grafu skierowanego $G$ oraz wierzchołków $s, t \in
V(G)$ wyznaczy odległość od $s$ do $t$ w czasie $O(m)$. 
Wskazówka: wykorzystaj sortowanie topologiczne (zadanie \ref{zad:tsort}).

\paragraph{Rozwiązanie.}
Dijkstra tylko, że zamiast kolejki $Q$ stosujemy
sortowanie topologiczne (średnia złożoność $O(m)$), 
po czym iter % PO CZYM ITER CO? :( po czym iter co...
\begin{algorithm}[H]
	\caption{Znajdowanie ujemnego cyklu}
	\begin{algorithmic}[1]
		\Procedure{FindDistanceInTree}{($T, w$): drzewo ważone}
		\State Niech odległość to tablica liczb, rozmiaru $V[G]$
		\State Niech kolejność to tablica liczb, rozmiaru $V[G]$, na
		$i$-tej komórce znajduje się wierzchołek, który ma 
		$i$-te miejsce w posortowanej topologicznie tablicy wierzchołków
		\State kolejność $\gets$ \textsc{TSort}($T$)
		\For{$i = 0, 1, \dots n - 1$}
		\State $u \gets \text{kolejność}[i]$
		\For{$v \in N(u)$}
		\If {$\text{odległość}[u] + w(uv) < 
			\text{odległość}[v]$}
		\State $\text{odległość}[v] \gets \text{odległość}[u] + w(uv)$
		\EndIf
		\EndFor 
		\EndFor
		\State \Return \false
		\EndProcedure
	\end{algorithmic}
	\label{Zadanie34}
\end{algorithm}

\subsection{Zadanie 5 -- Naiwna wersja algorytmu A\texorpdfstring{$^*$}{TEXT}}
\paragraph{Treść.}Znajdź przykład, dla 
którego algorytm A$^*$ nie zadziała zgodnie z oczekiwaniami, 
w którym spełnione
są wszystkie założenia 
poza 
,,dla każdej krawędzi $uv$ zachodzi $h(u) \leq h(v) + w(uv)$''.

\paragraph{Rozwiązanie.}% :/

\subsection{Zadanie 6 -- Poprawność algorytmu A\texorpdfstring{$^*$}{TEXT}}
\paragraph{Treść.}Udowodnij poprawność algorytmu 
A$^*$ i wskaż, w których miejscach wykorzystywane są jego założenia.
Wskazówka: zainspiruj się dowodem poprawności algorytmu Dijkstry.

\paragraph{Rozwiązanie.}Dowód twierdzenia \ref{aStar_proof}.

\subsection{Zadanie 7 -- Poprawność algorytmu Floyda-Warshalla}
\paragraph{Treść.}Udowodnij poprawność algorytmu Floyda-Warshalla. 
Wskazówka: niech 
$d^{(m)}(i, j)$ będzie długością
najkrótszej ścieżki od $i$ do $j$, której wewnętrzne wierzchołki należą
do zbioru $\{0, 1, 2, . . . , m - 1\}$; 
udowodnij, że po $l$
iteracjach zewnętrznej pętli dla każdych $i, j \in V (G)$ zachodzi 
odległość$[i, j] \leq d^{(l)}(i, j)$.

\paragraph{Rozwiązanie.}Dowód twierdzenia \ref{floydWarshall_proof}.
